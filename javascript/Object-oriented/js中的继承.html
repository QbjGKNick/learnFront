<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    /**
     * JS本身是基于面向对象开发的编程语言
     *  => 类：封装、继承、多态
     *
     * 封装：类也是一个函数，把实现一个功能的代码进行封装，以此实现“低耦合高内聚”
     * 多态：重载、重写
     *  重写：子类重写父类上的方法（伴随着继承运行的）
     *  重载：相同的方法，由于参数或者返回值不同，具备了不同的功能（JS中不具备严格意义上的重载），
     * JS中的重载：同一个方法内，根据传参不同实现不同的功能
     *  继承：子类继承父类中的方法
    */
  </script>

  <script>
    /**
     * 在JS语言中，它的继承和其他编程语言还是不太一样的
     * 继承的目的：让子类的实例同时也具备父类中的私有的属性和公共的类
     * 
     * 
    
    JS中第一中继承方法：原型继承（让子类的原型等于父类的实例即可）
        子类的实例，能够用子类私有的和原型上公有的
        父类的实例，可以使用 父类私有和原型上公有的
     
          原型继承：
              1）父类中私有和公有的属性方法，最后都变成子类实例公有的
              2）和其它语言不同的是，原型继承并不会把父类的属性方法“拷贝”给子类，
                而是让子类实例而基于__proto__原型链找到自己定义的属性和方法“指向/查找”方式的

            c1.__proto__.xxx = xxx 修改子类原型（原有父类的一个实例）中的内容，
              内容被修改后，对子类的其它实例有影响，但是对父类的实例不会有影响
            c1.__proto__.__proto__.xxx = xxx 直接修改父类原型，这样子不仅会影响
              其它父类的实例，也影响其它子类的实例
        
        function Parent() {
          this.x = 100
        }
        Parent.prototype.getX = function getX() {
          return this.x
        }

        function Child() {
          this.y = 200
        }
        Child.prototype = new Parent // 原型继承
        Child.prototype.constructor = Child
        Child.prototype.getY = function getY() {
          return this.y
        }

        let c1 = new Child
        console.log(c1)

    JS中第二种继承方式：CALL继承（只能继承父类中私有的，不能继承父类中公有的）
        
        function Parent() {
          this.x = 100
        }
        Parent.prototype.getX = function getX() {
          return this.x
        }

        function Child() {
          // 在类构造函数中，把父类当做普通方法执行（没有父类实例，父类原型上的那些东西也就和它没关系了）
          // this -> Child实例 c1
          Parent.call(this) // this.x = 100 相当于强制给c1这个实例设置一个私有的属性x，属性值100，
          // 相当于让子类的实例继承了父类的私有的属性，并且也变为了子类私有的属性，并且也变为了子类私有的属性“拷贝式”
          this.y = 200
        }
        Child.prototype.getY = function getY() {
          return this.y
        }

        let c1 = new Child
        console.log(c1)
     
    JS中第三种继承：寄生组合式继承（call继承+）

        function Parent() {
          this.x = 100
        }
        Parent.prototype.getX = function getX() {
          return this.x
        }

        function Child() {
          Parent.call(this)
          this.y = 200
        }
        // IE 不支持
        // Child.prototype.__proto__ = Parent.prototype
        Child.prototype = Object.create(Parent.prototype)
        Child.prototype.constructor = Child
        Child.prototype.getY = function getY() {
          return this.y
        }

        let c1 = new Child
        console.log(c1)
    */


    // 创建一个空对象，让其原型链指向obj
    // let obj = {
    //   xxx: 'xxx'
    // }
    // console.log(Object.create(obj))
  </script>

  <script>
    /* ES6中的类和继承 */
    class Parent {
      constructor () {
        this.x = 100
      }

      // Parent.prototype.getX = function...
      getX() {
        return this.x
      }
    }

    // 继承：extends Parent（类似于寄生组合继承）
    // 注意：继承后一定要在CONSTRUCTOR第一行加上SUPER
    class Child extends Parent {
      constructor () {
        super() // 类似于之前的CALL继承 super(100, 200)：相当于把Parent中constructor执行，传递了100和200
        this.y = 200
      }

      getY() {
        return this.y
      }
    }

    // Child() VM64:1 Uncaught TypeError: Class constructor Child cannot be invoked without 'new'
    // ES6中创建的类，不能当做普通函数执行，只能new执行
  </script>
</body>

</html>